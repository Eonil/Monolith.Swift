//
//  Analyser.swift
//  Text2
//
//  Created by Hoon H. on 10/21/14.
//
//

import Foundation


//protocol CursorType {
//	typealias	Element
//	
//	var available:Bool { get }
//	var current:Element { get }
//	var continuation:Self { get }
//}
//
//struct CharacterCursor: CursorType {
//	typealias	Element	=	Character
//	
//	var available:Bool {
//		get {
//			
//		}
//	}
//	var current:Element {
//		get {
//			
//		}
//	}
//	var continuation:CharacterCursor {
//		get {
//			
//		}
//	}
//}

enum Cursor<T> {
	typealias	Element	=	T
	case None
	case Available(current:T,continuation:()->Cursor)
	
	init(_ g1:GeneratorOf<T>) {
		var	g2	=	g1
		let	c1	=	g2.next()
		if let c2 = c1 {
			func continuate() -> Cursor {
				return	Cursor(g2)
			}
			self	=	Cursor.Available(current: c2, continuation: continuate)
		} else {
			self	=	Cursor.None
		}
	}
	
	var available:Bool {
		get {
			switch self {
				case None:	return	false
				default:	return	true
			}
		}
	}
	var current:T {
		get {
			switch self {
			case let Available(s):	return	s.current
			default:				fatalError("Cannot get current from `None` cursor.")
			}
		}
	}
	var continuation:Cursor {
		get {
			switch self {
			case let Available(s):	return	s.continuation()
			default:				fatalError("Cannot continue from `None` cursor.")
			}
		}
	}
}

struct Scanner<T> {
	typealias	Element	=	T
	typealias	Test	=	(Element) -> Bool
	
	static func or(options1:[Test])(e2:T) -> Bool {
		for opt1 in options1 {
			if opt1(e2) {
				return	true
			}
		}
		return	false
	}
	static func not(s1:Test)(e2:T) -> Bool {
		return	!s1(e2)
	}
}











//func analyse<E,A:Equatable>(a1:Analyser<E,A>)(cursor:Cursor<E>) -> Status<E,A> {
//	return	a1(cursor: cursor)
//}


///	Generic and dynamic syntax analyser.
///	Designed for quickly implementing flexible parser, but slow.
///
///	`Element` provides a type for minimal units that will be generated by the cursor.
///	`Annotation` provides a type for special notation of some produced node.
///
///	With this generic analyser, you can do lexing and parsing with one class.
///	This can be somewhat slow due to dynamic resolution of some values, but this can
///	provide quick implementation for specific syntax domains.
struct Analyser<Element,Annotation:Equatable> {
	typealias	Cursor			=	Text2.Cursor<Element>
	typealias	Status			=	Text2.Status<Element,Annotation>
	typealias	Node			=	Text2.Node<Element,Annotation>
	typealias	NodeList		=	Text2.NodeList<Element,Annotation>
	typealias	Component		=	Text2.Component<Element>
	typealias	ComponentList	=	Text2.ComponentList<Element>
	typealias	Rule			=	(cursor:Cursor) -> Status
	
	///	Cores.
	
	static func test(pass1:(Element)->Bool)(cursor:Cursor) -> Status {
		switch cursor {
		case Cursor.None:	return	Status.None
		case let Cursor.Available(current: e1, continuation: c2):
			switch pass1(e1) {
			case false:	return	Status.None
			case true:
				let	cs1	=	ComponentList(_items: [Component.Value(data: e1)])
				let	n1	=	Node(components: cs1, subnodes: NodeList())
				return		Status.Done(data: n1, continuation: c2())
			default:
				fatalError("Unknown instance of Boolean type value.")
			}
		}
	}
	
	///	Handles arbitrary number of ordered atom rules.
	///	The length of the atom list be can infinite in theory.
	///	You optionally can set minimum/maximum occurrences to constraint the iteration.
	///	It is not recommend to use this rule directly in your code. 
	///	Instead, consider using `sequence` or `repetition` for fixed number of ordered atoms 
	///	or repetition of single atom correspondingly.
	static func iteration(atoms as1:GeneratorOf<Rule>, minimumOccurrence:Int? = nil, maximumOccurrence:Int? = nil)(cursor:Cursor) -> Status {
		precondition(minimumOccurrence == nil || minimumOccurrence! >= 0)
		precondition(maximumOccurrence == nil || maximumOccurrence! >= 0)
		
		let	min1	=	minimumOccurrence == nil ? 0 : minimumOccurrence!
		let	max1	=	maximumOccurrence == nil ? Int.max : maximumOccurrence!		///	Practical implicit limit defined by platform.
		
		var	ns1	=	NodeList()
		var	cs1	=	ComponentList()
		var	c2	=	cursor
		for a1 in as1 {
			if c2.available {
				let s1 = a1(cursor: c2)
				switch s1 {
				case Status.Cancel:
					return	Status.Cancel
				case let Status.None:
					if ns1.keypoints {
						cs1	+=	ComponentList(_items: [Component.Error(message: "A node produced by a key-point rule discovered. Then it's an error if current sequence was not fully satisfied.")])
					} else {
						return	Status.None
					}
				case let Status.Done(s):
					ns1	+=	NodeList(s.data.annotation == nil ? [] : [s.data])
					cs1	+=	s.data.components
					c2	=	s.continuation
				}
				
				if cs1.count >= max1 {
					break
				}
			} else {
				break
			}
		}
		
		if ns1.count < min1 {
			return	Status.None
		}
		
		let	n1	=	Node(components: cs1, subnodes: ns1)
		return	Status.Done(data: n1, continuation: c2)
	}
	static func choice(options:[Rule])(cursor:Cursor) -> Status {
		for o1 in options {
			let	s1	=	o1(cursor: cursor)
			switch s1 {
			case Status.Cancel:									return	Status.Cancel
			case Status.None:									continue
			case let Status.Done(data: d1, continuation: c1):	return	s1
			}
		}
		return	Status.None
	}
	///	You can perform custom processing on node discovery.
	static func trigger(rule r1:Rule, filter f1:(Node,Cursor)->(Node,Cursor))(cursor:Cursor) -> Status {
		let	s1	=	r1(cursor: cursor)
		switch s1 {
		case Status.Cancel:
			return	Status.Cancel
		case Status.None:
			return	Status.None
		case let Status.Done(data: n2, continuation: c2):
			let	(n3,c3)	=	f1(n2, c2)
			return	Status.Done(data: n3, continuation: c3)
		}
	}
	
	
	
	
	
	///	Extensions.
	
	static func sequence(atoms:[Rule]) -> Rule {
		return	iteration(atoms: GeneratorOf<Rule>(atoms.generate()), minimumOccurrence: atoms.count, maximumOccurrence: atoms.count)
	}
	///	The `repetition` rule is a size optimisation of `sequence` rule for all same elements.
	///	Everything is just same.
	static func repetition(unit:Rule, min:Int? = nil, max:Int? = nil) -> Rule {
		func repeatInfinitely() -> Rule? {
			return	unit
		}
		return	iteration(atoms: GeneratorOf<Rule>(repeatInfinitely), minimumOccurrence: min, maximumOccurrence: max)
	}
	static func optional(unit:Rule) -> Rule {
		return	iteration(atoms: GeneratorOf<Rule>(GeneratorOfOne<Rule>(unit)), minimumOccurrence: 0, maximumOccurrence: 1)
	}

	static func annotation(rule r1:Rule, annotation anno1:Annotation) -> Rule {
		func annotate(s1:(Node,Cursor)) -> (Node,Cursor) {
			var	n2			=	s1.0
			n2.annotation	=	anno1
			return	(n2, s1.1)
		}
		return	trigger(rule: r1, filter: annotate)
	}
	static func keypoint(rule r1:Rule) -> Rule {
		func key(s1:(Node,Cursor)) -> (Node,Cursor) {
			var	n2			=	s1.0
			n2.keypoint		=	true
			return	(n2, s1.1)
		}
		return	trigger(rule: r1, filter: key)
	}
//	static func keypoint(analyse a1:Rule)(cursor c1:Cursor) -> Status {
//		let	s1	=	a1(cursor: c1)
//		switch s1 {
//		case Status.None:
//			return	Status.None
//		case let Status.Done(data: n1, continuation: c2):
//			let	n2	=	Node(keypoint: true, annotation: n1.annotation, components: n1.components, subnodes: n1.subnodes)	///	Ognores old keypoint marker.
//			return		Status.Done(data: n2, continuation: c2)
//		}
//	}
	
//	///	Let the analyser to dump out the produced node after parsing it.
//	///	This feature is designed for situations that you're using only custom triggers.
//	///	This will effectively make analyser as event-based parser.
//	///	But unfortunetaly, this needs language level continuation support to work, so suspended.
//	///
//	static func dump() -> Rule {
//		
//	}
}

enum Status<Element,Annotation:Equatable> {
	case Cancel
	case None
	case Done(data:Node<Element,Annotation>, continuation:Cursor<Element>)		///	Can be OK or an error.
}

extension Status {
	var cancel:Bool {
		get {
			switch self {
			case Cancel:	return	true
			default:		return	false
			}
		}
	}
	var done:Bool {
		get {
			switch self {
			case None:	return	false
			default:	return	true
			}
		}
	}
	var data:Node<Element,Annotation> {
		get {
			switch self {
			case let Done(s):	return	s.data
			default:			fatalError("Status is `None` and has no continuation cursor.")
			}
		}
	}
	var continuation:Cursor<Element> {
		get {
			switch self {
			case let Done(s):	return	s.continuation
			default:			fatalError("Status is `None` and has no continuation cursor.")
			}
		}
	}
}

struct Node<Element,Annotation:Equatable> {
	var	keypoint:Bool								///	If a component analyser is marked as keypoint, generated node will be marked as keypoint.
	var	annotation:Annotation?
	var	components:ComponentList<Element>
	var	subnodes:NodeList<Element,Annotation>
	
	init(keypoint:Bool, annotation:Annotation?, components:ComponentList<Element>, subnodes:NodeList<Element,Annotation>) {
		self.keypoint	=	keypoint
		self.annotation	=	annotation
		self.components	=	components
		self.subnodes	=	subnodes
	}
	init(components:ComponentList<Element>, subnodes:NodeList<Element,Annotation>) {
		self.init(keypoint: false, annotation: nil, components: components, subnodes: subnodes)
	}
}


enum Component<Element> {
	case Error(message:String)
	case Value(data:@autoclosure()->Element)
//	case Value(data:Cursor<Element>)				///	The cursor contains the current element, and also specifies next continuation point.
	
	var error:String? {
		get {
			switch self {
			case let .Error(s):	return	s.message
			default:			return	nil
			}
		}
	}
	var value:Element? {
		get {
			switch self {
			case let .Value(s):	return	s.data()
			default:			return	nil
			}
		}
	}
}















struct NodeList<E,A:Equatable>: SequenceType {
	typealias	Generator	=	GeneratorOf<Node<E,A>>
	
	init(_ items:[Node<E,A>] = []) {
		self._items	=	items
	}
	
	var count:Int {
		get {
			return	_items.count
		}
	}
	subscript(index:Int) -> Node<E,A> {
		get {
			return	_items[index]
		}
	}
	
	func filter(test1:(Node<E,A>)->Bool) -> NodeList {
		return	NodeList(_items.filter(test1))
	}
	
	func generate() -> Generator {
		return	GeneratorOf<Node<E,A>>(_items.generate())
	}
	
	///	Returns `true` if there's any keypoint node.
	var	keypoints:Bool {
		get {
			return	_items.map{ $0.keypoint }.reduce(false, combine: |)
		}
	}
	private var	_items	=	[] as [Node<E,A>]
}

func + <E,A> (l:NodeList<E,A>, r:NodeList<E,A>) -> NodeList<E,A> {
	return	NodeList(l._items + r._items)
}
func += <E,A> (inout l:NodeList<E,A>, r:NodeList<E,A>) {
	l	=	l + r
}




struct ComponentList<E>: SequenceType {
	typealias	Generator	=	GeneratorOf<Component<E>>
	
	var	error:Bool {
		get {
			return	_items.map { $0.error != nil }.reduce(false, combine: |)
		}
	}
	
	var count:Int {
		get {
			return	_items.count
		}
	}
	subscript(index:Int) -> Component<E> {
		get {
			return	_items[index]
		}
	}
	
	func generate() -> Generator {
		return	GeneratorOf<Component<E>>(_items.generate())
	}
	
	private var _items	=	[] as [Component<E>]
}

func + <E> (l:ComponentList<E>, r:ComponentList<E>) -> ComponentList<E> {
	return	ComponentList(_items: l._items + r._items)
}
func += <E> (inout l:ComponentList<E>, r:ComponentList<E>) {
	l	=	l + r
}
























